;
				const matched =
					match(prevNode, configure.prev) &&
					match(nextNode, configure.next);

				if (matched) {
					return configure.blankLine;
				}
			}
			return null;
		}

		return {
			ClassBody(node) {
				const body = node.body;

				for (let i = 0; i < body.length - 1; i++) {
					const curFirst = sourceCode.getFirstToken(body[i]);
					const { curLast, nextFirst } = getBoundaryTokens(
						body[i],
						body[i + 1],
					);
					const isMulti = !astUtils.isTokenOnSameLine(
						curFirst,
						curLast,
					);
					const skip = !isMulti && options[1].exceptAfterSingleLine;
					const beforePadding = findLastConsecutiveTokenAfter(
						curLast,
						nextFirst,
						1,
					);
					const afterPadding = findFirstConsecutiveTokenBefore(
						nextFirst,
						curLast,
						1,
					);
					const isPadded =
						afterPadding.loc.start.line -
							beforePadding.loc.end.line >
						1;
					const hasTokenInPadding = hasTokenOrCommentBetween(
						beforePadding,
						afterPadding,
					);
					const curLineLastToken = findLastConsecutiveTokenAfter(
						curLast,
						nextFir